/*
 * ARCHI - LVGL Port Implementation
 *
 * Initializes LVGL on ESP32-CYD by bridging hardware drivers (TFT, touch)
 * with LVGL callbacks and registration.
 */
extern "C" {
  #include "lvgl.h"
}

#include "lvgl_port.h"
#include "display_driver.h"
#include "touch_driver.h"
#include "board_config.h"

#include <Arduino.h>
#include <stdio.h>
#include <string>
#include <SPIFFS.h>

static lv_disp_draw_buf_t s_draw_buf;
static lv_color_t s_draw_buf_1[LV_HOR_RES_MAX * 10];

static lv_disp_t* g_disp = NULL;
static lv_indev_t* g_indev_touch = NULL;

// Reminder: LVGL image assets must be raw RGB565 binaries generated by the LVGL image converter,
// not PNG/JPEG files renamed with a .bin extension.

static void log_spiffs_dir(const char* path)
{
  File dir = SPIFFS.open(path);
  if (!dir || !dir.isDirectory()) {
    Serial.print("ARCHI: Cannot open directory: ");
    Serial.println(path);
    return;
  }

  Serial.print("ARCHI: Listing ");
  Serial.println(path);

  File file = dir.openNextFile();
  while (file) {
    Serial.print("  ");
    Serial.print(file.name());
    Serial.print(" (size: ");
    Serial.print(file.size());
    Serial.println(" bytes)");
    file = dir.openNextFile();
  }
}

static void* fs_open(lv_fs_drv_t* drv, const char* path, lv_fs_mode_t mode)
{
  (void)drv;

  std::string full_path = path ? path : "";
  if (!full_path.empty() && full_path[0] != '/') {
    full_path = "/" + full_path;
  }

  const char* open_mode = (mode & LV_FS_MODE_WR) ? "w" : "r";

  File file = SPIFFS.open(full_path.c_str(), open_mode);
  if (!file) {
    Serial.println("ARCHI: LVGL fs_open FAILED");
    return NULL;
  }
  return new File(file);
}

static lv_fs_res_t fs_close(lv_fs_drv_t* drv, void* file_p)
{
  (void)drv;

  File* file = static_cast<File*>(file_p);
  if (!file) {
    return LV_FS_RES_UNKNOWN;
  }

  file->close();
  delete file;
  return LV_FS_RES_OK;
}

static lv_fs_res_t fs_read(lv_fs_drv_t* drv, void* file_p, void* buf, uint32_t btr, uint32_t* br)
{
  (void)drv;

  File* file = static_cast<File*>(file_p);
  if (!file) {
    return LV_FS_RES_UNKNOWN;
  }

  size_t read_len = file->read(static_cast<uint8_t*>(buf), btr);
  if (br) {
    *br = static_cast<uint32_t>(read_len);
  }

  return LV_FS_RES_OK;
}

static lv_fs_res_t fs_seek(lv_fs_drv_t* drv, void* file_p, uint32_t pos, lv_fs_whence_t whence)
{
  (void)drv;

  File* file = static_cast<File*>(file_p);
  if (!file) {
    return LV_FS_RES_UNKNOWN;
  }

  SeekMode seek_mode = SeekSet;
  switch (whence) {
    case LV_FS_SEEK_CUR:
      seek_mode = SeekCur;
      break;
    case LV_FS_SEEK_END:
      seek_mode = SeekEnd;
      break;
    case LV_FS_SEEK_SET:
    default:
      seek_mode = SeekSet;
      break;
  }

  return file->seek(pos, seek_mode) ? LV_FS_RES_OK : LV_FS_RES_UNKNOWN;
}

static lv_fs_res_t fs_tell(lv_fs_drv_t* drv, void* file_p, uint32_t* pos_p)
{
  (void)drv;

  File* file = static_cast<File*>(file_p);
  if (!file || !pos_p) {
    return LV_FS_RES_UNKNOWN;
  }

  *pos_p = static_cast<uint32_t>(file->position());
  return LV_FS_RES_OK;
}

static void archi_apply_theme(void)
{
  lv_theme_t* th = lv_theme_default_init(
      lv_disp_get_default(),
      lv_palette_main(LV_PALETTE_BLUE),
      lv_palette_main(LV_PALETTE_DEEP_PURPLE),
      true,
      LV_FONT_DEFAULT);

  if (th) {
    lv_disp_set_theme(lv_disp_get_default(), th);
  }
}

// LVGL flush callback bridging to hardware driver
static void my_disp_flush(lv_disp_drv_t* drv, const lv_area_t* area, lv_color_t* color_p)
{
  (void)drv;
  int32_t x1 = area->x1;
  int32_t y1 = area->y1;
  int32_t x2 = area->x2;
  int32_t y2 = area->y2;
  uint32_t w = (uint32_t)(x2 - x1 + 1);
  uint32_t h = (uint32_t)(y2 - y1 + 1);

  display_hw_push_pixels(x1, y1, w, h, reinterpret_cast<const uint16_t*>(color_p));
  lv_disp_flush_ready(drv);
}

// Touch read callback using touch driver API
static void my_touch_read(lv_indev_drv_t* indev_drv, lv_indev_data_t* data)
{
  (void)indev_drv;
  uint16_t x = 0, y = 0;
  bool pressed = cyd_touch_read(&x, &y);

  if (pressed) {
    data->point.x = x;
    data->point.y = y;
    data->state = LV_INDEV_STATE_PR;
  } else {
    data->state = LV_INDEV_STATE_REL;
  }
}

void lvgl_port_init(void)
{
  lv_init();

  bool spiffs_ok = SPIFFS.begin(true);
  Serial.print("ARCHI: SPIFFS begin result: ");
  Serial.println(spiffs_ok ? "OK" : "FAIL");
  log_spiffs_dir("/");
  log_spiffs_dir("/img");

  static lv_fs_drv_t fs_drv;
  lv_fs_drv_init(&fs_drv);
  fs_drv.letter = 'S';
  fs_drv.open_cb = fs_open;
  fs_drv.close_cb = fs_close;
  fs_drv.read_cb = fs_read;
  fs_drv.seek_cb = fs_seek;
  fs_drv.tell_cb = fs_tell;
  lv_fs_drv_register(&fs_drv);

  printf("ARCHI: Initializing display hardware...\n");
  display_hw_init();

  lv_disp_draw_buf_init(&s_draw_buf, s_draw_buf_1, NULL, LV_HOR_RES_MAX * 10);

  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  disp_drv.hor_res = LV_HOR_RES_MAX;
  disp_drv.ver_res = LV_VER_RES_MAX;
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &s_draw_buf;

  g_disp = lv_disp_drv_register(&disp_drv);

  printf("ARCHI: Initializing touch hardware...\n");
  cyd_touch_init();

  static lv_indev_drv_t indev_drv;
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_POINTER;
  indev_drv.read_cb = my_touch_read;
  g_indev_touch = lv_indev_drv_register(&indev_drv);

  archi_apply_theme();

  printf("ARCHI: LVGL port initialized\n");
}

void lvgl_port_deinit(void)
{
  display_hw_deinit();
  cyd_touch_deinit();

  printf("ARCHI: LVGL port deinitialized\n");
}

lv_disp_t* lvgl_port_get_disp(void)
{
  return g_disp;
}

lv_indev_t* lvgl_port_get_indev_touch(void)
{
  return g_indev_touch;
}
